#! /usr/bin/env python

# downbecause
#    
# Produce errors for offline nodes based on moab and torque information
#                                                        
# Written by Chris Samuel, csamuel@vpac.org              
# Copyright (C) 2009 Victorian Partnership for Advanced Computing

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or   
# (at your option) any later version.                                 

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  
# GNU General Public License for more details.                   

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys

def nodefreein(node):
    from subprocess import Popen, PIPE
    proc = Popen(['nodefreein', node], stdout=PIPE, stderr=PIPE)
    return_code = proc.wait()
    if return_code == 0:
        nodefreein = proc.stdout.read()
    else:
        print "ERROR: %s:\n%s" % (return_code, proc.stderr.read())
        sys.exit(-1)

    line_break = nodefreein.split()
    nodefreein_result = ' '.join(line_break[2:])

    return nodefreein_result.strip()

def get_moab_reason(node):
    from subprocess import Popen, PIPE
    proc = Popen(['checknode', node], stdout=PIPE, stderr=PIPE)
    return_code = proc.wait()
    if return_code == 0:
        checknode = proc.stdout.read()
    else:
        print "ERROR: %s:\n%s" % (return_code, proc.stderr.read())
        sys.exit(-1)

    checknode_list = checknode.split('\n')

    reason = "NO REASON"

    for line in checknode_list:
        if line.find('node rm message') != -1:
            line_break = line.split('\'')
            reason = line_break[1]

    return reason

if __name__ == "__main__":

    downnodes = []

    config = open('/usr/local/recluse/config', 'r')
    our_config = config.readlines()

    for line in our_config:
        if line.startswith('cluster='):
            clusterline = line.split('=')
            cluster = clusterline[1].rstrip('" \n').lstrip('" \n')

    from subprocess import Popen, PIPE
    proc = Popen(['pbsnodes', '-l', '-n'], stdout=PIPE, stderr=PIPE)
    return_code = proc.wait()
    if return_code == 0:
        pbsnodes = proc.stdout.read()
    else:
        proc = Popen(['pbsnodes', '-l'], stdout=PIPE, stderr=PIPE)
        return_code = proc.wait()
        if return_code == 0:
            pbsnodes = proc.stdout.read()
        else:
            print "ERROR: %s:\n%s" % (return_code, proc.stderr.read())
            sys.exit(-1)

    proc = Popen(['diagnose', '-n'], stdout=PIPE, stderr=PIPE)
    return_code = proc.wait()
    if return_code == 0:
        diagnose = proc.stdout.read()
    else:
        print "ERROR: %s:\n%s" % (return_code, proc.stderr.read())
        sys.exit(-1)

    pbsnodes_list = pbsnodes.split('\n')
    diagnose_list = diagnose.split('\n')

    nodes = {}

    for line in pbsnodes_list:
        if line.startswith(cluster):
            line_break = line.split()
            node = line_break[0]
            reason = ' '.join(line_break[2:])
            if node not in downnodes:
                downnodes.append(node)
                nodes[node] = {'pbs': reason}
                nodes[node]['moab'] = "NO REASON"

    for line in diagnose_list:
        if line.startswith(cluster) and ( line.find('Down') != -1 or line.find('Drained') != -1 ):
            line_break = line.split()
            node = line_break[0]
            reason = get_moab_reason(node)
            if node not in downnodes:
                downnodes.append(node)
                nodes[node] = {'moab': reason}
                nodes[node]['pbs'] = "NO REASON"
            else:
                nodes[node]['moab'] = reason

    downnodes.sort()

    longest_pbs = 0
    longest_moab = 0

    for node in downnodes:
        pbs_count = len(nodes[node]['pbs'])
        moab_count = len(nodes[node]['moab'])
        if pbs_count > longest_pbs:
            longest_pbs = pbs_count
        if moab_count > longest_moab:
            longest_moab = moab_count

    for node in downnodes:
        print node + " -- " + nodes[node]['pbs'],
        for i in range(len(nodes[node]['pbs']), longest_pbs):
            print "",
        print "-- " + nodes[node]['moab'],
        for i in range(len(nodes[node]['moab']), longest_moab):
            print "",
        print "-- " + nodefreein(node)
